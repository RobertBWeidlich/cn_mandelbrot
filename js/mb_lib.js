/////////////////////////////////////////////////////////////////////////
// file:    mb_lib.js
// author:  rbw
// date:    Tue Sep 10 16:48:50 PDT 2013
// version: 0.0.3
// purpose: generate Mandelbrot set
/////////////////////////////////////////////////////////////////////////
/**
 * define a 2-D array of mandelbrot values
 *
 * @param  float xcp0 -     starting point on the complex plane
 * @param  float ycp0 -     starting point on the complex plane
 * @param  float xcp1 -     end point on the complex plane
 * @param  float ycp1 -     end point on the complex plane
 *                          (note: ignored, autogenerated...)
 * @param  int   w_px -     width of display in pixels
 * @param  int   h_px -     height of display in pixels
 *                        complex plane
 * @return array of mb1() arrays, of h_px size
 *
 * todo: match aspect ratios of rectangle on complex plane and rectangle
 *       of display.
 */
function mb2(xcp0, ycp0, xcp1, ycp1, w_px, h_px) {
	var rv = [];
	rv['xcp0'] = xcp0;
	rv['ycp0'] = ycp0;
	rv['xcp1'] = xcp1;
	rv['ycp1'] = ycp1;
	rv['w_px'] = w_px;
	rv['h_px'] = h_px;

	var xcp = xcp1 - xcp0;
	var ycp = ycp1 - ycp0;
	rv['xcp'] = xcp;
	rv['ycp'] = ycp;

	//var incr = ycp / h_px;
	// todo: incr_y and incr_x should be the same
	var incr_y = ycp / h_px;
	var incr_x = xcp / w_px;
	var incr = incr_y;
	if (incr_y > incr_x) {
		incr = incr_x;
	}
	rv['incr'] = incr;
	//rv['incr_y'] = incr_y;
	//rv['incr_x'] = incr_x;
	//console.log('incr_y: ' + incr_y);
	//console.log('incr_x: ' + incr_x);
	//console.log('incr: ' + incr);
    rv['data'] = data;

	var data = [];
	for (var i = 0; i < h_px; i++) {
		var y = ycp0 + (i * incr);
		var m = mb1(xcp0, xcp1, y, w_px);
		data[i] = m;
		//console.log(m);
	}
    rv['data'] = data;
	
	return rv;
}


/**
 * define an array of mandelbrot values for a line
 *
 * @param  float x0 - x coordinate of start of line
 * @param  float x1 - x coordinate of end of line
 * @param  float y  - y coordinate of line
 * @param  int   n  - number of evenly-spaced increments along the line
 *
 * @return
 *   {"x0":   -2.768532347,
 *    "x1":   3.1415962543,
 *    "y":    -1.49265,
 *    "incr": 0.59101286013
 *    "n":    11
 *    "data": [0,1,13,99,99,67,27,89,99,99,99]
 *   }
 */
function mb1(x0, x1, y, n) {
	var rv = [];
	rv['x0'] = x0;
	rv['x1'] = x1;
	rv['y'] = y;
	var incr = (x1 - x0) / n;
	rv['incr'] = incr;
    x = x0;
	var d = [];
	for (var i = 0; i < n; i++) {
		x += incr;
		var v = mb0(x, y);
		d[i] = v;
		//console.log(v, x, y)
	}
	rv['data'] = d;

	return rv;
}

/**
 * define mandelbrot value for a single point
 *
 * @param  float c_real - x coordinate
 * @param  float c_im -   y coordinate
 *
 * @return int 0 to 99
 */
function mb0(c_real, c_im) {
	var zr = 0.0;
	var zi = 0.0;
	var zlr = 0.0;
	var zli = 0.0;
	var i = 0;

	for (i = 0; i < 100; ++i) {
		zr2 = zr * zr;
		zi2 = zi * zi;
		if ((zr2 + zi2) >= 4.0)
			break;
		zlr = zr2 - zi2;
		zli = 2.0 * (zr * zi);
		zr = zlr + c_real;
		zi = zli + c_im;
	}

	return i;
}

/**
 * generate rainbow color map, using a hybrid of a square wave function
 * and a triangle function.
 *
 * @return
 * 		[len: 100    // size of r, g, b arrays
 * 		 r:   [0, 0, 0, 0, ...]
 * 		 g:   [173, 184, 194, 204, ...]
 * 		 b:   [255, 255, 255, 255, ...]
 *		]
 *
 */
function tri_square_palette()
{
	var xx =      0.0;
	var theta =   0.0
	var r, g, b = 0.0;
	var rv = [];

	for (i = 0; i < 100; i++) {
	//for (i = 17; i < 117; i++) {
	//for (i = 27; i < 127; i++) {
	//for (i = 100; i < 200; i++) {
		var cell = [];
		var v = (4.0 * i) / 100.0;
		cell['i'] = i;
		cell['v'] = v;
		var ca = tri_square(v - 2.0);
		var cb = tri_square(v);
		var cc = tri_square(v - 4.0);
		cell['r'] = ca;
		cell['g'] = cb;
		cell['b'] = cc;
		rv.push(cell);
	}

	// convert to hash of 3 arrays, for R, G, and B values,
	// each with 100 members, ranging from 0 to 255
	a100 = []
	rv_len = rv.length;

	rr = []
	gg = []
	bb = []
	for (i = 0; i < rv_len; i++) {
		r = rv[i];
		rr.push(r.r);
		gg.push(r.g);
		bb.push(r.b);
	}
	a100.len = rv_len;
	a100.r = rr;
	a100.g = gg;
	a100.b = bb;

	return a100;
}

/**
 * @return 0 to 255
 */
function tri_square(x) {
	var v = 0.0;
    var p = 0;

	if (x < 0.0) {
		for (; x < 0.0; x += 6.0)
			;
	}
	if (x > 6.0) {
		for (; x > 6.0; x -= 6.0)
			;
	}
	if (x < 1.0) {
		v = x;
	}
	else if (x < 3.0) {
		v = 1.0;
	}
	else if (x < 4.0) {
		v = (4.0 - x);
	}
	else {
		v = 0.0;
	}
	p = v * 255;
	return Math.round(p);
}

// exports used only in node.js??
//exports.mb0 = mb0;
//exports.mb1 = mb1;
//exports.mb2 = mb2;
//exports.tri_square_palette = tri_square_palette;


